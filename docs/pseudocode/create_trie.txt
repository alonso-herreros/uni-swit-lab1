//Recursive function for creating an LC-trie
//FIRST: first member of the subinterval
//n: it indicates how many IP directions do we have in the actual
//subinterval
//PRE: how many equal initial bits do we have in the directions
//of the interval
//For example, if we had: 192.168: 11000000 10
//and 192.169: 11000000 10
//In this case pre=10
//If in a subinterval of the trie, we have that pre is
//smaller, it will update
//POS: first free position in the vector that holds the
//representation of the trie

TrieNode* create_trie(int first, int n, int pre, int pos) {
    //If the interval contains only one string, we simply create a leaf
    if(n==1){
        trie[pos] = {0, 0, first};
        return;
    }
    //If not we compute the skip value (which is the number of bits that 
    //can be ignored)
    skip = computeSkip(pre, first, n);
    //and the branch value (quantity of direct children nodes);
    //For allocating the memory of the tree it is enough to check the first free
    //position in the vector
    //In the pseudocode, it is assumed that memory has been allocated for the root node
    //before the procedure is invoked
    adr = allocateMemory(2^branch);
    trie[pos] = {branch, skip, adr};

    //auxiliary value
    p = first
    for bitpat = 0 to 2^branch - 1{
        k = 0
        while(EXTRACT(pre + skip, branch, base[p + k])== bitpat)
            k = k + 1
        //Recursive call
        build(p, k, pre + skip, adr + bitpat);
        p = p + k;
    }
}

